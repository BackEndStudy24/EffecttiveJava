# 2장. 객체의 생성과 파괴

## Item 1. 생성자 대신 정적 팩터리 메서드를 고려하라.

1. 이름을 가질 수 있다.
    * 생성자는 클래스 이름과 동일해야 하기 때문에 이름을 명확하게 지정할 수 없다.
    * 메서드는 의미를 부여한 이름을 가질 수 있기 때문에 반환될 객체의 특성을 쉽게 묘사할 수 있다.
   
2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
    * 정적 팩터리 메서드는 이미 생성된 객체를 반환한다.
    * 생성 비용이 큰 객체가 자주 요청되는 경우, 성능이 향상된다.

3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다?????
    * 사용자는 부모 클래스 타입만 알더라도 하위 타입의 클래스를 사용할 수 있다.
    * 내부적으로 어떤 구체적인 하위 클래스가 쓰이는지 몰라도 된다.

4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
    * 반환 타입의 유연성을 제공한다.
    * 반환 타입이 해당 클래스가 아닌 하위 타입으로도 객체 반환이 가능하다.
    * 사실 3번이랑 같은 소리인 것 같다...?

5. 정적 팩터리 메서드는 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다?????
    * 반환될 객체를 미리 결정하지 않아도 된다.
    * 예를 들어, 식당을 차리는 경우에 메뉴판은 미리 만들고 셰프를 나중에 고용하게 된다면 메뉴는 당장 준비되지 못한다.
    * 후에 셰프를 고용하고 요리가 준비 가능하다면 그때서 메뉴가 제공될 수 있다.
    * 메뉴판 구성 -> 정적 팩터리 메서드 작성 시점 / 메뉴 -> 셰프가 고용 된 후 제공 가능

***

## Item 2. 생성자에 매개변수가 많다면 빌더를 고려하라.

* 정적 팩터리 메서드와 생성자는 모두 매개변수가 많아질 수록 대응하기 어렵다는 단점이 있다.
* 빌더는 점층적 생성자 패턴의 장점과 자바 빈즈 패턴의 장점을 모두 가지고 있다.

1. 점층적 생성자 패턴
    * 과거 프로그래머들이 많이 사용하던 방식이다.
    * 매개변수의 개수를 기준으로 같은 이름의 생성자를 계속해서 만들어낸다.
    * 단점 : 클라이언트 코드를 작성하거나 읽기에 어렵다.

2. 자바 빈즈 패턴
    * 선택 매개변수가 많을 때 활용할 수 있는 두 번째 대안이다.
    * 매개변수가 없는 비어있는 생성자를 만들고 setter 메서드를 통해 원하는 매개변수의 값만 설정한다.
    * 단점 : 불변성을 유지할 수 없고 객체 하나를 생성하는데 여러 개의 메서드를 호출해야 한다.

3. 빌더 패턴
    * 필수 매개변수만 생성자를 통해 호출하여 빌더 객체를 생성한다.
    * 일종의 setter 메서드를 통해 원하는 매개변수의 값만 설정한다.
    * 마지막으로 build() 메서드를 호출하여 필요한 객체를 생성한다.
    * 빌더의 setter 메서드들은 빌더 자신(this)를 반환하기 때문에 연쇄적으로 호출할 수 있다?????
    * -> 뭔소리..?
    * 계층적으로 설계된 클래스와 함께 쓰기에 좋다. -> 이건 하나도 이해 못함;;;;;;;
    * 코드도 하나도 이해 못함...
   
## Item 3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.

* 싱글턴은 인스턴스를 오직 하나만 생성하는 클래스이다.

1. public static final 필드 방식
    * 생성자는 `private` 으로 감춰둔다.
    * 필드 방식으로 미리 생성자 선언을 한다면, 해당 클래스의 필드를 초기화할 때 딱 한 번만 호출된다.
    * 예외로 권한이 있는 클라이언트는 리플렉션 API를 사용하여 `private` 생성자를 호출할 수 있다.
    * 해당 클래스가 싱글턴임이 API에서 명백히 드러난다는 장점이 있다.

2. 정적 팩터리 메서드 방식
    * 생성자는 `private` 으로 감춰둔다.
    * 1번 방식에서 필드의 생성자는 `public` 이었지만 해당 방식에서는 필드 생성자를 `private` 으로 감춘다.
    * 대신 정적 팩터리 메서드를 생성하여 해당 필드를 반환한다.
    * API를 바꾸지 않고 추후에 싱글턴이 아니게 변경할 수 있다.

3. 원소가 하나인 열거 타입으로 선언
    * 더 간결하고 추가 노력 없이 직렬화가 가능하다.
    * 역직렬화나 리플렉션에 대해 안전하기에 싱글턴 패턴에 권장되는 방식이다.

## Item 4. 인스턴스화를 막으려거든 private 생성자를 사용하라.

* 이따금 정적 메서드, 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것이다. -> ?????????????????
* 컴파일러가 기본 생성자를 만드는 경우는 오직 명시된 생성자가 없을 때 뿐이다.
* `private` 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.
* 상위 클래스의 생성자를 호출하는 상속 방식을 사용할 수 없다.
